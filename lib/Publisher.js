// Generated by CoffeeScript 1.5.0
var Publisher, async, crypto, expireDate, fs, knox, logger, mime, moment, path, walk, zlib,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

path = require('path');

fs = require('fs');

zlib = require('zlib');

crypto = require('crypto');

knox = require('knox');

mime = require('mime');

async = require('async');

moment = require('moment');

walk = require('findr').walk;

logger = require('./loggers').get('util');

expireDate = moment().add('years', 10).format('ddd, DD MMM YYYY') + " 12:00:00 GMT";

module.exports = Publisher = (function() {

  function Publisher(config) {
    this.publish = __bind(this.publish, this);    this.client = knox.createClient(config);
  }

  Publisher.prototype.publishDir = function(_arg, cb) {
    var dest, filter, origin,
      _this = this;
    origin = _arg.origin, dest = _arg.dest, filter = _arg.filter;
    filter || (filter = function() {
      return true;
    });
    origin = path.join(path.resolve(origin));
    logger.info("uploading new files from '" + origin + "' to '" + dest + "'");
    return walk(origin, filter, function(err, fileItems) {
      var file, files, q, stat;
      if (err) {
        return logger.error(err);
      }
      files = (function() {
        var _results;
        _results = [];
        for (file in fileItems) {
          stat = fileItems[file];
          if (stat.isFile()) {
            _results.push(file);
          }
        }
        return _results;
      })();
      q = async.queue(_this.publish, 2);
      q.drain = function() {
        logger.debug("All files were uploaded");
        return cb();
      };
      return files.forEach(function(file) {
        var filename;
        filename = file.replace(origin, dest);
        return q.push({
          file: file,
          filename: filename
        }, function(err) {
          if (err) {
            return logger.error("Error uploading " + filename, err.statusCode);
          }
        });
      });
    });
  };

  Publisher.prototype.publish = function(_arg, cb) {
    var file, filename,
      _this = this;
    file = _arg.file, filename = _arg.filename;
    return async.waterfall([
      function(cb) {
        return fs.readFile(file, cb);
      }, function(buf, cb) {
        if (/\.(css|js)$/.test(file)) {
          return zlib.gzip(buf, function(err, zip) {
            if (err) {
              return cb(new Error("Error zipping " + file));
            }
            return cb(null, zip, {
              'Content-Encoding': 'gzip'
            });
          });
        } else {
          return cb(null, buf, {});
        }
      }, function(buf, headers, cb) {
        headers['Expires'] = expireDate;
        headers['Content-Type'] = mime.lookup(file);
        headers['Content-Length'] = buf.length;
        headers['x-amz-acl'] = 'public-read';
        return _this.client.headFile(filename, function(err, res) {
          var md5, req;
          if (err) {
            return cb(err);
          }
          md5 = '"' + crypto.createHash('md5').update(buf).digest('hex') + '"';
          if (md5 === res.headers.etag) {
            logger.debug("[skip]    " + filename);
            return cb(null);
          } else if (res.headers.etag) {
            logger.debug("[UPDATE]  " + filename);
          } else {
            logger.debug("[ADD]     " + filename);
          }
          req = _this.client.put(filename, headers);
          req.on('response', function(res) {
            var _ref;
            if ((199 < (_ref = res.statusCode) && _ref < 299)) {
              return cb();
            }
            return cb(res);
          });
          return req.end(buf);
        });
      }
    ], cb);
  };

  return Publisher;

})();
